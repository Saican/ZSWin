# ZScript Windows v0.3

![](https://github.com/Saican/ZSWin/blob/master/README/ZSWin_Logo.png)

## A Generic GUI API for (G)ZDoom

**Written in ZScript!**

ZScript Windows is a generic GUI API aimed at enabling unique implementations that are flexible and dynamic, specific to the needs of the user, fast, powerful, and simple to use. The entire ZScript Windows API is written in (G)ZDoom's native ZScript, allowing users to design GUI systems rendered at the game's framerate **and multiplayer compatible**.

Unlike the old GDCC dinosaur, Z-Windows, ZScript Windows is actually fairly straightforward to use for developers who are familiar with C++, if not familiar with ZScript.  Getting ZScript Windows up and working is even easier than Z-Windows, requiring no extra compilers or batch files.  ZScript Windows functions just like any other (G)ZDoom mod.

##### A Bit of History and the Concept of ZScript Windows:
I started delving into GUI design several years ago when I wanted mouse-driven menus for a long dead project called *[all] Alone*.  At the time the only way to do this was through ACS methods.  This pretty much immediately made my GUI systems incompatible with multiplayer games.  My project was singleplayer so it that did not matter.  The project went through three iterations before finally being shelved, and the GUI system went through two distinct iterations as well, one being a full rewrite.  Both systems included the HUD.  This ACS GUI system, while functional, was not expandable.  Then I did an experiment.

I wanted to see if I could create any sort of tiling method for a background image in preparation to create a text-box system.  My method was unreasonable, but it gave me another idea: use one image for a background and clip it off based on a specific width and height.  Z-Windows was born.  Over the course of development, Z-Windows was quickly ported to GDCC, a full C compiler that compiles to ACS bytecode.  This laid the foundation for the concept of a ZWindow.

ZScript Windows, and obviously Z-Windows, gets its name not from Microsoft Windows, but from the X Window System (also ZDoom), which provides the basic GUI functionality for many UNIX-like operating systems. Just like X, ZScript Windows provides just the basic GUI framework without mandating what the actual interface is supposed to look like. The term windows is both a GUI organizational concept and a programming concept the interpretations of which can vary dramatically. ZScript Windows does deviate from X in that the functionality of ZScript Windows is geared toward complete GUI management in a video game architecture and as such can mimic the appearance of an actual operating system but is not actually an operating system.  However, implementation does not restrict what the user intends to do with a window, thus only the limits of ZScript actually restrict the user.

###### The Z-Windows Concept
C is not an object-oriented programming language, however it supports structures so it sort of is.  C++, however is an object-oriented programming language, thus ZScript is too.  So a ZWindow is an object.  In Z-Windows, every object was a structure, including the actual window.  This limited the functionality because, in C, structures cannot contain methods.  To get around this, there are function pointers, and this was used to give windows a Procedure Function, much like the ZScript Tick() function.  In fact, ZScript Windows are ZScript Thinkers!  To function correctly, a window must be somehow spawned into the game world, and this is best accomplished through the Thinker class.

This creates a bit of conundrum.  ZScript has explicitly defined scopes for methods, meaning that there is a distinct separation between the actual game simulation logic and what could essentially be lumped into the rendering logic.  And to further explain, it basically means that stuff drawn on the screen, the UI scope, cannot have any direct impact on the level currently running, the play, or playism, scope, and vice versa.  However ZScript provides a very bare-bones, very DIY, method of allowing communication between contexts: net events.  This approach allows for the most flexibility, net events and the associated processes can be challenging to design around, but allows the user to build what they need.  In this case ZScript Windows needs an interface to send and receive events from both contexts.

To that end, all ZObjects in ZScript Windows are essentially the same object; that is they derive from a base class, even the window class, which inherits from the engine's Thinker class.  The Thinker is a "play" scoped object, however it also contains UI scoped methods, especially events that are called from the ZScript Windows Event System, the UI handler.  So this also means that all ZObjects also draw themselves; sort of - the Event System's RenderOverlay method is still the root draw call but all ZObjects define their own draw methods which are called from a draw event.

This makes ZScript Windows somewhat homogenous as well, the main deviations are in the controls themselves as they define their own unique characteristics and handle their own draw methods.  The advantage to this is naming consistency; a window has an "xLocation", as does a button, as does a text object, etc.  The "xLocation" (and "yLocation") are variables defined in the base object that all ZObjects inherit from.  Conversly, a text object contains a variable to represent the desired text wrapping, while such a variable is absent from every other control not needing such a variable, because this variable is define only in the text object.

[Back to Project Main](https://github.com/Saican/ZSWin "Back to Project Main")